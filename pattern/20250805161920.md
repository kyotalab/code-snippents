---
id: 20250805161920
title: Rust エラーファーストドメイン設計におけるエラー定義Clap統合セット
type: pattern
tags: [rust, error-first, cli, clap]
created: 2025-08-05 16:19:20
updated: 2025-08-05 16:19:20
---

## Rust エラーファーストドメイン設計におけるエラー定義Clap統合セット

### 8. Clap統合

```rust
// =============================================================================
// 8. clapとの統合（CLI引数解析）
// =============================================================================

#[cfg(feature = "clap")]
impl From<clap::Error> for AppError {
    fn from(error: clap::Error) -> Self {
        match error.kind() {
            clap::error::ErrorKind::MissingRequiredArgument => {
                Self::missing_argument(error.to_string())
            }
            clap::error::ErrorKind::InvalidValue => Self::invalid_argument(error.to_string()),
            _ => Self::invalid_argument(error.to_string()),
        }
    }
}
```

---

### 9. よくあるCLIパターン

```rust
// =============================================================================
// 9. よくあるCLIパターンのヘルパー
// =============================================================================

/// 環境変数の安全な取得
pub fn get_env_var(name: &str) -> AppResult<String> {
    std::env::var(name).map_err(|_| AppError::environment(name, "Environment variable not found"))
}

/// 環境変数の取得（デフォルト値付き）
pub fn get_env_var_or_default(name: &str, default: &str) -> String {
    std::env::var(name).unwrap_or_else(|_| default.to_string())
}

/// ディレクトリの存在確認・作成
pub fn ensure_directory(path: impl Into<PathBuf>) -> AppResult<()> {
    let path = path.into();

    if !path.exists() {
        std::fs::create_dir_all(&path)
            .map_err(|e| AppError::file_io(&path, format!("Cannot create directory: {}", e)))?;
    } else if !path.is_dir() {
        return Err(AppError::invalid_path(&path));
    }

    Ok(())
}

/// ファイル拡張子のチェック
pub fn check_file_extension(path: &PathBuf, expected: &str) -> AppResult<()> {
    match path.extension().and_then(|ext| ext.to_str()) {
        Some(actual) if actual.eq_ignore_ascii_case(expected) => Ok(()),
        Some(actual) => Err(AppError::invalid_file_format(path, expected, actual)),
        None => Err(AppError::invalid_file_format(
            path,
            expected,
            "no extension",
        )),
    }
}

/// プログレスバー付きの長時間処理（indicatifライブラリ使用時）
#[cfg(feature = "indicatif")]
pub fn with_progress<T, F>(items: Vec<T>, operation: F) -> AppResult<Vec<T>>
where
    F: Fn(T) -> AppResult<T>,
{
    use indicatif::{ProgressBar, ProgressStyle};

    let pb = ProgressBar::new(items.len() as u64);
    pb.set_style(
        ProgressStyle::default_bar()
            .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} {msg}")
            .unwrap()
            .progress_chars("#>-"),
    );

    let mut results = Vec::new();

    for (i, item) in items.into_iter().enumerate() {
        pb.set_message(format!("Processing item {}", i + 1));

        match operation(item) {
            Ok(result) => {
                results.push(result);
                pb.inc(1);
            }
            Err(error) => {
                pb.finish_with_message("Failed");
                return Err(error);
            }
        }
    }

    pb.finish_with_message("Completed");
    Ok(results)
}
```

---

### 10. 設定ファイル管理

```rust
// =============================================================================
// 10. 設定ファイル管理
// =============================================================================

/// アプリケーション設定の標準的な場所を取得
pub fn get_config_dir(app_name: &str) -> AppResult<PathBuf> {
    let config_dir = if cfg!(target_os = "windows") {
        // Windows: %APPDATA%\{app_name}
        std::env::var("APPDATA")
            .map_err(|_| AppError::environment("APPDATA", "Windows APPDATA not found"))?
    } else {
        // Unix系: ~/.config/{app_name} または $XDG_CONFIG_HOME/{app_name}
        match std::env::var("XDG_CONFIG_HOME") {
            Ok(xdg_config) => xdg_config,
            Err(_) => {
                let home = std::env::var("HOME")
                    .map_err(|_| AppError::environment("HOME", "HOME directory not found"))?;
                format!("{}/.config", home)
            }
        }
    };

    Ok(PathBuf::from(config_dir).join(app_name))
}

/// 設定ファイルの読み込み
pub fn load_config<T>(app_name: &str, config_file: &str) -> AppResult<T>
where
    T: serde::de::DeserializeOwned + Default,
{
    let config_dir = get_config_dir(app_name)?;
    let config_path = config_dir.join(config_file);

    if !config_path.exists() {
        // 設定ファイルが存在しない場合はデフォルト値を返す
        return Ok(T::default());
    }

    read_json_file(config_path)
}

/// 設定ファイルの保存
pub fn save_config<T>(app_name: &str, config_file: &str, config: &T) -> AppResult<()>
where
    T: serde::Serialize,
{
    let config_dir = get_config_dir(app_name)?;
    ensure_directory(&config_dir)?;

    let config_path = config_dir.join(config_file);
    write_json_file(config_path, config)
}
```

---

### 11. ログ設定

```rust
// =============================================================================
// 11. ログ設定のシンプルなヘルパー
// =============================================================================

/// 簡単なログ設定（envとtracingを使用）
#[cfg(feature = "tracing")]
pub fn setup_logging() -> AppResult<()> {
    use tracing_subscriber::{EnvFilter, fmt, prelude::*};

    let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"));

    tracing_subscriber::registry()
        .with(fmt::layer())
        .with(env_filter)
        .init();

    Ok(())
}

/// エラーのログ出力
#[cfg(feature = "tracing")]
impl AppError {
    pub fn log(&self) {
        match self {
            AppError::Internal { .. } => {
                tracing::error!("{}", self);
            }
            AppError::Network { .. } | AppError::Api { .. } => {
                tracing::warn!("{}", self);
            }
            _ => {
                tracing::info!("{}", self);
            }
        }
    }
}
```

---

### Dependencies

```toml
[dependencies]
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# オプション機能
clap = { version = "4.0", optional = true }
serde_yaml = { version = "0.9", optional = true }
csv = { version = "1.2", optional = true }
reqwest = { version = "0.11", features = ["json"], optional = true }
tracing = { version = "0.1", optional = true }
tracing-subscriber = { version = "0.3", optional = true }
indicatif = { version = "0.17", optional = true }

[dev-dependencies]
tempfile = "3.0"

[features]
default = ["clap"]
full = ["clap", "serde_yaml", "csv", "reqwest", "tracing", "indicatif"]
cli = ["clap"]
formats = ["serde_yaml", "csv"]
http = ["reqwest"]
logging = ["tracing", "tracing-subscriber"]
progress = ["indicatif"]
```

---

### Related Notes

- [Rust エラーファーストドメイン設計におけるCLIエラー型定義](../pattern/20250805161442.md)
- [rust-cli-error-design.rs](./rust-cli-error-design.rs)
