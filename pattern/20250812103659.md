---
id: 20250812103659
title: Go エラーファーストドメイン設計におけるエラー定義基本セット
type: pattern
tags: [go, error-first-design, cli]
created: 2025-08-12 10:36:59
updated: 2025-08-12 10:44:34
---

## Go エラーファーストドメイン設計におけるエラー定義基本セット

### 1. CLIツール用エラー定義

```go
import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// =============================================================================
// 1. CLIツール用シンプルエラー型
// =============================================================================

// ErrorType はエラーの種類を表す
type ErrorType string

const (
	ErrorTypeUsage    ErrorType = "USAGE_ERROR"      // 使用方法エラー
	ErrorTypeFile     ErrorType = "FILE_ERROR"       // ファイル関連エラー
	ErrorTypeFormat   ErrorType = "FORMAT_ERROR"     // データ形式エラー
	ErrorTypeConfig   ErrorType = "CONFIG_ERROR"     // 設定エラー
	ErrorTypeNetwork  ErrorType = "NETWORK_ERROR"    // ネットワークエラー
	ErrorTypeInternal ErrorType = "INTERNAL_ERROR"   // 内部エラー
)

// AppError はCLIアプリケーション用のシンプルなエラー型
type AppError struct {
	Type    ErrorType `json:"type"`
	Message string    `json:"message"`
	Detail  string    `json:"detail,omitempty"`
	Cause   error     `json:"-"` // 元のエラー（JSON出力しない）
}

// Error はerrorインターフェースを実装
func (e *AppError) Error() string {
	if e.Detail != "" {
		return fmt.Sprintf("[%s] %s: %s", e.Type, e.Message, e.Detail)
	}
	return fmt.Sprintf("[%s] %s", e.Type, e.Message)
}

// Unwrap は元のエラーを返す（Go 1.13以降のエラーラッピング対応）
func (e *AppError) Unwrap() error {
	return e.Cause
}
```

---

### 2. コンストラクタ関数

```go
// =============================================================================
// 2. エラー作成関数
// =============================================================================

// NewUsageError は使用方法エラーを作成
func NewUsageError(message string) *AppError {
	return &AppError{
		Type:    ErrorTypeUsage,
		Message: message,
	}
}

// NewFileError はファイル関連エラーを作成
func NewFileError(message, detail string) *AppError {
	return &AppError{
		Type:    ErrorTypeFile,
		Message: message,
		Detail:  detail,
	}
}

// NewFormatError はデータ形式エラーを作成
func NewFormatError(message, detail string) *AppError {
	return &AppError{
		Type:    ErrorTypeFormat,
		Message: message,
		Detail:  detail,
	}
}

// NewConfigError は設定エラーを作成
func NewConfigError(message, detail string) *AppError {
	return &AppError{
		Type:    ErrorTypeConfig,
		Message: message,
		Detail:  detail,
	}
}

// NewNetworkError はネットワークエラーを作成
func NewNetworkError(message, detail string) *AppError {
	return &AppError{
		Type:    ErrorTypeNetwork,
		Message: message,
		Detail:  detail,
	}
}

// NewInternalError は内部エラーを作成
func NewInternalError(message string) *AppError {
	return &AppError{
		Type:    ErrorTypeInternal,
		Message: message,
	}
}

// WithCause は原因エラーを設定
func (e *AppError) WithCause(cause error) *AppError {
	e.Cause = cause
	return e
}

// WithDetail は詳細情報を設定
func (e *AppError) WithDetail(detail string) *AppError {
	e.Detail = detail
	return e
}
```

---

### 3. 標準ライブラリエラーからの自動変換

```go
// =============================================================================
// 3. 標準エラーからの変換
// =============================================================================

// WrapError は標準エラーをAppErrorに変換
func WrapError(err error, errorType ErrorType, message string) *AppError {
	if err == nil {
		return nil
	}

	// 既にAppErrorの場合はそのまま返す
	if appErr, ok := err.(*AppError); ok {
		return appErr
	}

	return &AppError{
		Type:    errorType,
		Message: message,
		Cause:   err,
	}
}

// WrapFileError はファイル操作エラーをラップ
func WrapFileError(err error, operation, path string) *AppError {
	if err == nil {
		return nil
	}

	if os.IsNotExist(err) {
		return NewFileError("file not found", path).WithCause(err)
	}
	if os.IsPermission(err) {
		return NewFileError("permission denied", fmt.Sprintf("%s: %s", operation, path)).WithCause(err)
	}

	return NewFileError(operation+" failed", path).WithCause(err)
}

// WrapFormatError はデータ形式エラーをラップ
func WrapFormatError(err error, format, file string) *AppError {
	if err == nil {
		return nil
	}
	return NewFormatError(format+" parse error", file).WithCause(err)
}
```

---

### 4. CLI向けユーティリティ（exit_code, user_message等）

```go
// =============================================================================
// 4. CLIフレンドリーな機能
// =============================================================================

// ExitCode はエラーの終了コードを返す
func (e *AppError) ExitCode() int {
	switch e.Type {
	case ErrorTypeUsage:
		return 1 // 使用方法エラー
	case ErrorTypeFile:
		return 2 // ファイルエラー
	case ErrorTypeFormat:
		return 3 // データ形式エラー
	case ErrorTypeConfig:
		return 4 // 設定エラー
	case ErrorTypeNetwork:
		return 5 // ネットワークエラー
	case ErrorTypeInternal:
		return 99 // 内部エラー
	default:
		return 1
	}
}

// ShouldShowHelp はヘルプを表示すべきかどうか
func (e *AppError) ShouldShowHelp() bool {
	return e.Type == ErrorTypeUsage
}

// UserMessage はユーザー向けの分かりやすいメッセージを返す
func (e *AppError) UserMessage() string {
	switch e.Type {
	case ErrorTypeUsage:
		return fmt.Sprintf("%s\nUse --help for usage information.", e.Error())
	case ErrorTypeFile:
		return fmt.Sprintf("%s\nPlease check the file path and permissions.", e.Error())
	case ErrorTypeFormat:
		return fmt.Sprintf("%s\nPlease check the file format.", e.Error())
	case ErrorTypeConfig:
		return fmt.Sprintf("%s\nPlease check your configuration.", e.Error())
	case ErrorTypeNetwork:
		return fmt.Sprintf("%s\nPlease check your internet connection.", e.Error())
	default:
		return e.Error()
	}
}
```

---

### 5. エラーハンドリングヘルパー

```go
// =============================================================================
// 5. エラーハンドリングヘルパー
// =============================================================================

// HandleError はエラーを処理してプログラムを終了
func HandleError(err error) {
	if err == nil {
		return
	}

	if appErr, ok := err.(*AppError); ok {
		fmt.Fprintf(os.Stderr, "Error: %s\n", appErr.UserMessage())

		if appErr.ShouldShowHelp() {
			fmt.Fprintf(os.Stderr, "\nFor more information, run with --help\n")
		}

		os.Exit(appErr.ExitCode())
	} else {
		// 標準エラーの場合
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

// HandleErrorWithCleanup はクリーンアップ付きでエラーを処理
func HandleErrorWithCleanup(err error, cleanup func()) {
	if cleanup != nil {
		defer cleanup()
	}
	HandleError(err)
}
```

---

### 6. エラーハンドリングヘルパー

```go
// =============================================================================
// 6. ファイル操作ヘルパー
// =============================================================================

// ReadFile はファイルを安全に読み込む
func ReadFile(path string) ([]byte, error) {
	if path == "" {
		return nil, NewUsageError("file path cannot be empty")
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, WrapFileError(err, "read", path)
	}

	return data, nil
}

// WriteFile はファイルを安全に書き込む
func WriteFile(path string, data []byte) error {
	if path == "" {
		return NewUsageError("file path cannot be empty")
	}

	// 親ディレクトリが存在しない場合は作成
	dir := filepath.Dir(path)
	if dir != "." && dir != "/" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return WrapFileError(err, "create directory", dir)
		}
	}

	err := os.WriteFile(path, data, 0644)
	if err != nil {
		return WrapFileError(err, "write", path)
	}

	return nil
}

// ReadJSONFile はJSONファイルを読み込む
func ReadJSONFile(path string, v interface{}) error {
	data, err := ReadFile(path)
	if err != nil {
		return err
	}

	if err := json.Unmarshal(data, v); err != nil {
		return WrapFormatError(err, "JSON", path)
	}

	return nil
}

// WriteJSONFile はJSONファイルを書き込む
func WriteJSONFile(path string, v interface{}) error {
	data, err := json.MarshalIndent(v, "", "  ")
	if err != nil {
		return NewFormatError("JSON marshal error", path).WithCause(err)
	}

	return WriteFile(path, data)
}
```

---

### Related Notes
