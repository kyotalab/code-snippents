---
id: 20250812104356
title: Go エラーファーストドメイン設計におけるエラー定義Cobra統合セット
type: pattern
tags: [go, error-first-design, cli, cobra]
created: 2025-08-12 10:43:56
updated: 2025-08-12 10:43:56
---

## Go エラーファーストドメイン設計におけるエラー定義Cobra統合セット

### 7. Config管理

```go
// =============================================================================
// 7. 簡単な設定管理
// =============================================================================

// Config は設定構造体の例
type Config struct {
	InputDir  string `json:"input_dir"`
	OutputDir string `json:"output_dir"`
	Verbose   bool   `json:"verbose"`
}

// LoadConfig は設定ファイルを読み込む
func LoadConfig(path string) (*Config, error) {
	// ファイルが存在しない場合はデフォルト設定を返す
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return &Config{
			InputDir:  ".",
			OutputDir: "./output",
			Verbose:   false,
		}, nil
	}

	var config Config
	if err := ReadJSONFile(path, &config); err != nil {
		return nil, err
	}

	return &config, nil
}

// SaveConfig は設定ファイルを保存
func SaveConfig(path string, config *Config) error {
	return WriteJSONFile(path, config)
}
```

---

### 8. 使用例

```go
// =============================================================================
// 8. 使用例
// =============================================================================

// 実用的な使用例を示すための関数群

// ProcessFile はファイル処理の例
func ProcessFile(inputPath, outputPath string) error {
	// 入力ファイル読み込み
	data, err := ReadFile(inputPath)
	if err != nil {
		return err
	}

	// 何らかの処理（例：大文字変換）
	processed := strings.ToUpper(string(data))

	// 出力ファイル書き込み
	if err := WriteFile(outputPath, []byte(processed)); err != nil {
		return err
	}

	return nil
}

// ConvertJSON はJSON変換の例
func ConvertJSON(inputPath, outputPath string) error {
	// JSONファイル読み込み
	var data map[string]interface{}
	if err := ReadJSONFile(inputPath, &data); err != nil {
		return err
	}

	// 何らかの変換処理
	data["processed"] = true
	data["timestamp"] = "2024-01-01T00:00:00Z"

	// JSON書き込み
	if err := WriteJSONFile(outputPath, data); err != nil {
		return err
	}

	return nil
}

// ValidateArgs は引数バリデーションの例
func ValidateArgs(args []string) error {
	if len(args) < 2 {
		return NewUsageError("insufficient arguments: input file required")
	}

	inputFile := args[1]
	if inputFile == "" {
		return NewUsageError("input file cannot be empty")
	}

	if !strings.HasSuffix(inputFile, ".json") {
		return NewUsageError("input file must be a JSON file")
	}

	return nil
}
```

---

### 9. メイン関数の典型例

```go
// =============================================================================
// 9. メイン関数の典型例
// =============================================================================

// ExampleMain はCLIツールのメイン関数の例
func ExampleMain() {
	// 引数チェック
	args := os.Args
	if err := ValidateArgs(args); err != nil {
		HandleError(err)
	}

	inputFile := args[1]
	outputFile := "output.json"
	if len(args) > 2 {
		outputFile = args[2]
	}

	// 設定読み込み
	config, err := LoadConfig("config.json")
	if err != nil {
		HandleError(err)
	}

	if config.Verbose {
		fmt.Printf("Processing %s -> %s\n", inputFile, outputFile)
	}

	// メイン処理
	if err := ConvertJSON(inputFile, outputFile); err != nil {
		HandleError(err)
	}

	fmt.Println("Processing completed successfully")
}
```

---

### 10. テスト用ヘルパー

```go
// =============================================================================
// 10. テスト用ヘルパー
// =============================================================================

// CreateTestFile はテスト用ファイルを作成
func CreateTestFile(path, content string) error {
	return WriteFile(path, []byte(content))
}

// CleanupTestFiles はテストファイルをクリーンアップ
func CleanupTestFiles(paths ...string) {
	for _, path := range paths {
		os.Remove(path)
	}
}

// AssertError はテスト用のエラー検証
func AssertError(err error, expectedType ErrorType) bool {
	if err == nil {
		return false
	}

	appErr, ok := err.(*AppError)
	if !ok {
		return false
	}

	return appErr.Type == expectedType
}
```

---

### 11. 実際のプロジェクトでの使用テンプレート

```go
// =============================================================================
// 11. 実際のプロジェクトでの使用テンプレート
// =============================================================================

/*
main.go のテンプレート:

package main

import (
	"fmt"
	"os"
)

func main() {
	if err := run(); err != nil {
		HandleError(err)
	}
}

func run() error {
	args := os.Args

	// バージョン表示
	if len(args) > 1 && (args[1] == "--version" || args[1] == "-v") {
		fmt.Printf("%s version 1.0.0\n", os.Args[0])
		return nil
	}

	// ヘルプ表示
	if len(args) > 1 && (args[1] == "--help" || args[1] == "-h") {
		printHelp()
		return nil
	}

	// 引数チェック
	if len(args) < 2 {
		return NewUsageError("missing input file argument")
	}

	inputFile := args[1]
	outputFile := "output.json"
	if len(args) > 2 {
		outputFile = args[2]
	}

	// メイン処理
	return ProcessFile(inputFile, outputFile)
}

func printHelp() {
	fmt.Printf("Usage: %s <input-file> [output-file]\n", os.Args[0])
	fmt.Println("\nOptions:")
	fmt.Println("  --help, -h     Show this help")
	fmt.Println("  --version, -v  Show version")
}
*/

func main() {
	// 使用例の実行
	ExampleMain()
}
```

---

### 12. 便利機能関数

```go
// =============================================================================
// 12. 追加の便利機能
// =============================================================================

// IsTerminal は標準出力がターミナルかどうかを判定
func IsTerminal() bool {
	// 簡単な判定（Unix系）
	stat, _ := os.Stdout.Stat()
	return (stat.Mode() & os.ModeCharDevice) != 0
}

// PrintVerbose は詳細モード時のみ出力
func PrintVerbose(verbose bool, format string, args ...interface{}) {
	if verbose {
		fmt.Fprintf(os.Stderr, "[VERBOSE] "+format+"\n", args...)
	}
}

// PrintProgress は進捗表示（シンプル版）
func PrintProgress(current, total int, description string) {
	if IsTerminal() {
		fmt.Fprintf(os.Stderr, "\r[%d/%d] %s", current, total, description)
		if current == total {
			fmt.Fprintf(os.Stderr, "\n")
		}
	}
}
```

---

### 13. 環境変数の処理

```go
// =============================================================================
// 13. 環境変数の処理
// =============================================================================

// GetEnv は環境変数を取得（デフォルト値付き）
func GetEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// GetEnvRequired は必須環境変数を取得
func GetEnvRequired(key string) (string, error) {
	value := os.Getenv(key)
	if value == "" {
		return "", NewConfigError("required environment variable not set", key)
	}
	return value, nil
}
```

---

### 14. ディレクトリ操作

```go
// =============================================================================
// 14. ディレクトリ操作
// =============================================================================

// EnsureDir はディレクトリの存在を確認し、なければ作成
func EnsureDir(path string) error {
	if path == "" {
		return NewUsageError("directory path cannot be empty")
	}

	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			// ディレクトリが存在しない場合は作成
			if err := os.MkdirAll(path, 0755); err != nil {
				return WrapFileError(err, "create directory", path)
			}
			return nil
		}
		return WrapFileError(err, "check directory", path)
	}

	if !info.IsDir() {
		return NewFileError("path is not a directory", path)
	}

	return nil
}

// ListFiles は指定されたパターンのファイル一覧を取得
func ListFiles(dir, pattern string) ([]string, error) {
	if err := EnsureDir(dir); err != nil {
		return nil, err
	}

	fullPattern := filepath.Join(dir, pattern)
	matches, err := filepath.Glob(fullPattern)
	if err != nil {
		return nil, NewFileError("pattern matching failed", fullPattern).WithCause(err)
	}

	return matches, nil
}
```

---

### 15. 簡単なログ機能

```go
// =============================================================================
// 15. 簡単なログ機能
// =============================================================================

// LogLevel はログレベル
type LogLevel int

const (
	LogLevelError LogLevel = iota
	LogLevelWarn
	LogLevelInfo
	LogLevelDebug
)

// Logger はシンプルなロガー
type Logger struct {
	level LogLevel
	out   io.Writer
}

// NewLogger は新しいロガーを作成
func NewLogger(level LogLevel) *Logger {
	return &Logger{
		level: level,
		out:   os.Stderr,
	}
}

// Error はエラーログを出力
func (l *Logger) Error(format string, args ...interface{}) {
	if l.level >= LogLevelError {
		fmt.Fprintf(l.out, "[ERROR] "+format+"\n", args...)
	}
}

// Warn は警告ログを出力
func (l *Logger) Warn(format string, args ...interface{}) {
	if l.level >= LogLevelWarn {
		fmt.Fprintf(l.out, "[WARN] "+format+"\n", args...)
	}
}

// Info は情報ログを出力
func (l *Logger) Info(format string, args ...interface{}) {
	if l.level >= LogLevelInfo {
		fmt.Fprintf(l.out, "[INFO] "+format+"\n", args...)
	}
}

// Debug はデバッグログを出力
func (l *Logger) Debug(format string, args ...interface{}) {
	if l.level >= LogLevelDebug {
		fmt.Fprintf(l.out, "[DEBUG] "+format+"\n", args...)
	}
}

// LogError はAppErrorをログ出力
func (l *Logger) LogError(err error) {
	if appErr, ok := err.(*AppError); ok {
		switch appErr.Type {
		case ErrorTypeUsage:
			l.Info("Usage error: %s", appErr.Message)
		case ErrorTypeInternal:
			l.Error("Internal error: %s", appErr.Error())
		default:
			l.Warn("Error: %s", appErr.Error())
		}
	} else {
		l.Error("Unexpected error: %v", err)
	}
}
```

---

### 16. 完全なCLIツール例

```go
// =============================================================================
// 16. 完全なCLIツール例
// =============================================================================

// FileProcessor はファイル処理ツールの例
type FileProcessor struct {
	config *Config
	logger *Logger
}

// NewFileProcessor は新しいFileProcessorを作成
func NewFileProcessor(configPath string, verbose bool) (*FileProcessor, error) {
	// 設定読み込み
	config, err := LoadConfig(configPath)
	if err != nil {
		return nil, err
	}

	// ログレベル設定
	logLevel := LogLevelWarn
	if verbose {
		logLevel = LogLevelDebug
	}
	logger := NewLogger(logLevel)

	return &FileProcessor{
		config: config,
		logger: logger,
	}, nil
}

// ProcessDirectory はディレクトリ内のファイルを一括処理
func (fp *FileProcessor) ProcessDirectory(inputDir, outputDir string) error {
	fp.logger.Info("Processing directory: %s -> %s", inputDir, outputDir)

	// 出力ディレクトリ作成
	if err := EnsureDir(outputDir); err != nil {
		return err
	}

	// JSONファイル一覧取得
	files, err := ListFiles(inputDir, "*.json")
	if err != nil {
		return err
	}

	if len(files) == 0 {
		return NewFileError("no JSON files found", inputDir)
	}

	fp.logger.Info("Found %d JSON files", len(files))

	// ファイル処理
	for i, file := range files {
		PrintProgress(i+1, len(files), filepath.Base(file))

		outputFile := filepath.Join(outputDir, filepath.Base(file))
		if err := ConvertJSON(file, outputFile); err != nil {
			fp.logger.LogError(err)
			return err
		}

		fp.logger.Debug("Processed: %s", file)
	}

	fp.logger.Info("Successfully processed %d files", len(files))
	return nil
}
```

---

### 17. より実用的なメイン関数例

```go
// =============================================================================
// 17. より実用的なメイン関数例
// =============================================================================

// RealMain は実用的なメイン関数の例
func RealMain() error {
	args := os.Args

	// フラグ解析（簡易版）
	var (
		inputDir   = "."
		outputDir  = "./output"
		configFile = "config.json"
		verbose    = false
		showHelp   = false
		showVersion = false
	)

	// 簡単なフラグ処理
	for i, arg := range args[1:] {
		switch arg {
		case "--help", "-h":
			showHelp = true
		case "--version", "-v":
			showVersion = true
		case "--verbose":
			verbose = true
		case "--input", "-i":
			if i+2 < len(args) {
				inputDir = args[i+2]
			}
		case "--output", "-o":
			if i+2 < len(args) {
				outputDir = args[i+2]
			}
		case "--config", "-c":
			if i+2 < len(args) {
				configFile = args[i+2]
			}
		}
	}

	if showVersion {
		fmt.Println("file-processor version 1.0.0")
		return nil
	}

	if showHelp {
		fmt.Printf("Usage: %s [options]\n", filepath.Base(args[0]))
		fmt.Println("\nOptions:")
		fmt.Println("  --input, -i DIR     Input directory (default: current)")
		fmt.Println("  --output, -o DIR    Output directory (default: ./output)")
		fmt.Println("  --config, -c FILE   Config file (default: config.json)")
		fmt.Println("  --verbose           Enable verbose output")
		fmt.Println("  --help, -h          Show this help")
		fmt.Println("  --version, -v       Show version")
		return nil
	}

	// プロセッサー作成
	processor, err := NewFileProcessor(configFile, verbose)
	if err != nil {
		return err
	}

	// メイン処理実行
	return processor.ProcessDirectory(inputDir, outputDir)
}
```

---

### 18. パッケージ化のためのテンプレート

```go
// =============================================================================
// 18. パッケージ化のためのテンプレート
// =============================================================================

/*
プロジェクト構造の例:

my-cli-tool/
├── main.go              // メイン関数
├── errors.go            // このファイルの内容
├── config.json          // 設定ファイル
├── go.mod               // Go modules
└── README.md            // 使用方法

go.mod の例:
module my-cli-tool

go 1.21

main.go の最小構成:
package main

func main() {
    if err := run(); err != nil {
        HandleError(err)
    }
}

func run() error {
    args := os.Args
    if len(args) < 2 {
        return NewUsageError("missing input file")
    }

    inputFile := args[1]
    outputFile := "output.json"
    if len(args) > 2 {
        outputFile = args[2]
    }

    return ConvertJSON(inputFile, outputFile)
}
*/
```

---

### 19.

```go
// =============================================================================
// 19. 使用方法まとめとベストプラクティス
// =============================================================================

/*
Go CLIツール用エラーハンドリング - 使用ガイド

## 基本パターン

1. エラー作成:
   err := NewUsageError("missing argument")
   err := NewFileError("cannot read", path)

2. エラーラッピング:
   return WrapFileError(err, "read", path)

3. エラー処理:
   if err := operation(); err != nil {
       HandleError(err)  // プログラム終了
   }

## ファイル操作

1. 安全な読み書き:
   data, err := ReadFile(path)
   err := WriteFile(path, data)

2. JSON操作:
   err := ReadJSONFile(path, &obj)
   err := WriteJSONFile(path, obj)

## 設定管理

1. 設定読み込み:
   config, err := LoadConfig("config.json")

2. 環境変数:
   value := GetEnv("MY_VAR", "default")
   value, err := GetEnvRequired("REQUIRED_VAR")

## 終了コード

- USAGE_ERROR: 1 (使用方法エラー)
- FILE_ERROR: 2 (ファイルエラー)
- FORMAT_ERROR: 3 (形式エラー)
- CONFIG_ERROR: 4 (設定エラー)
- NETWORK_ERROR: 5 (ネットワークエラー)
- INTERNAL_ERROR: 99 (内部エラー)

## ベストプラクティス

1. エラーは早期に返す
2. 適切なエラー型を使用
3. 詳細情報を含める
4. ユーザーフレンドリーなメッセージ
5. HandleError()で一元的に処理

## RustとGoの比較

| 観点 | Rust | Go |
|------|------|-----|
| エラー型 | Result<T, E> | error interface |
| エラーチェック | ? operator | if err != nil |
| 学習コスト | 高 | 低 |
| 型安全性 | コンパイル時 | ランタイム |
| パフォーマンス | ゼロコスト | 構造体アロケーション |
| エコシステム | 型システム中心 | インターフェース中心 |

このGo実装により、シンプルで実用的なCLIツール向けエラーハンドリングが実現できます。
*/
```

---

### Related Notes

-
