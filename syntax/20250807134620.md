---
id: 20250807134620
title: Go vs Rust ファイル書き込み比較
type: syntax
tags: [go, rust, file-io, error-handling]
created: 2025-08-07 13:46:20
updated: 2025-08-07 13:57:14
---

## Go vs Rust ファイル書き込み比較

### 基本アプローチの違い

#### ファイルオープン戦略

| 項目            | Go               | Rust                 |
| --------------- | ---------------- | -------------------- |
| **低レベルAPI** | `os.OpenFile()`  | `OpenOptions::new()` |
| **高レベルAPI** | `os.WriteFile()` | `fs::write()`        |
| **フラグ指定**  | ビット演算 `｜`  | メソッドチェーン     |

#### エラーハンドリングパターン

| Go                                                                        | Rust                                                 |
| ------------------------------------------------------------------------- | ---------------------------------------------------- |
| `go<br/>if err != nil {<br/>    return fmt.Errorf("...: %w", err)<br/>} ` | `rust<br/>OpenOptions::new()<br/>    .open(path)?; ` |

---

### 詳細比較

#### 1. ファイルオープンの文法

```go
// Go: フラグをビット演算で組み合わせ
file, err := os.OpenFile(path,
    os.O_WRONLY|os.O_CREATE|os.O_APPEND,
    0644)
```

```rust
// Rust: メソッドチェーンで設定
let mut file = OpenOptions::new()
    .write(true)
    .create(true)
    .append(true)
    .open(path)?;
```

#### 2. 書き込み操作

```go
// Go: 複数の書き込み方法
file.Write([]byte(content))     // []byte必要
file.WriteString(content)       // 直接string
```

```rust
// Rust: 統一されたインターフェース
file.write_all(content.as_bytes())?;  // &[u8]が必要
```

#### 3. リソース管理

```go
// Go: defer文による遅延実行
defer file.Close()
```

```rust
// Rust: スコープ終了時に自動的にドロップ
// 明示的なclose不要（RAIIパターン）
```

---

### 高レベルAPIの比較

#### シンプルなファイル書き込み（上書き）

```go
// Go
err := os.WriteFile(path, []byte(content), 0644)
```

```rust
// Rust
fs::write(path, content)?;
```

#### ファイル追記の実装パターン

```go
// Go: OpenFileを使用
file, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
if err != nil {
    return err
}
defer file.Close()
_, err = file.WriteString(content)
```

```rust
// Rust: OpenOptionsを使用
let mut file = OpenOptions::new()
    .write(true)
    .create(true)
    .append(true)
    .open(path)?;
file.write_all(content.as_bytes())?;
```

---

### エラーハンドリングの特徴

#### Go のエラーハンドリング

- **明示的チェック**: すべてのエラーを明示的に処理
- **エラーラッピング**: `fmt.Errorf`と`%w`でコンテキスト追加
- **戻り値**: `(result, error)`のタプル形式

#### Rust のエラーハンドリング

- **Result型**: 型システムレベルでエラーを強制
- **?演算子**: エラー伝播の簡潔な記法
- **コンパイル時保証**: 未処理エラーはコンパイルエラー

---

### 設計哲学の違い

#### Go: 明示性重視

```go
// エラーの流れが明確
file, err := os.OpenFile(path, flags, perm)
if err != nil {
    return fmt.Errorf("open failed: %w", err)
}
defer file.Close()

_, err = file.WriteString(content)
if err != nil {
    return fmt.Errorf("write failed: %w", err)
}
```

#### Rust: 型安全性重視

```rust
// 型システムがエラー処理を強制
let mut file = OpenOptions::new()
    .write(true)
    .create(true)
    .append(true)
    .open(path)?;  // エラーは自動的に伝播

file.write_all(content.as_bytes())?;  // 同様に自動伝播
```

---

### パフォーマンス特性

#### メモリ管理

- **Go**: ガベージコレクション、ファイルハンドルは明示的クローズ
- **Rust**: 所有権システム、RAIIによる自動リソース管理

#### システムコール

- **Go**: 直接的なシステムコール、オーバーヘッド最小
- **Rust**: ゼロコスト抽象化、同等のパフォーマンス

---

### 実践的な選択指針

#### Go を選ぶ場合

- チーム開発で読みやすさを重視
- デバッグのしやすさが重要
- 明示的なエラーハンドリングを好む

#### Rust を選ぶ場合

- 型安全性を最重視
- パフォーマンスが重要
- メモリ安全性が必須

---

### まとめ

両言語ともファイル書き込みの基本機能は同等だが、アプローチが異なる：

- **Go**: 明示的で直感的、学習コストが低い
- **Rust**: 型安全で高性能、学習コストは高いが安全性が高い

---

### Related Notes

- [Go ファイル書き込みミニマム実装](./20250807135347.md)
- [Rust ファイル書き込みミニマム実装](./20250807135531.md)
