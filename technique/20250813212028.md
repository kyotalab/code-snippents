---
id: 20250813212028
title: Rust vs Go パターンマッチング・条件分岐比較ガイド
type: technique
tags: [rust, go, pattern-matching]
created: 2025-08-13 21:20:28
updated: 2025-08-13 21:20:28
---

## Rust vs Go: パターンマッチング・条件分岐比較ガイド

### 概要

RustとGoにおける複雑な条件分岐の実装方法を比較。特にRustのタプルパターンマッチングと、Goでの同等機能実装パターンを分析。

---

### 🦀 Rust: パターンマッチングの威力

#### 基本実装（タプルパターンマッチング）

```rust
match (l_flg, w_flg, c_flg) {
    (true, false, false) => println!("    {} lines", len),
    (true, true, false) => println!("    {} lines    {} words", len, cnt),
    (true, true, true) => println!("    {} lines    {} words    {} bytes", len, cnt, bytes),
    (false, true, false) => println!("    {} words", cnt),
    (false, true, true) => println!("    {} words    {} bytes", cnt, bytes),
    (false, false, true) => println!("    {} bytes", bytes),
    (true, false, true) => println!("    {} lines    {} bytes", len, bytes),
    (false, false, false) => println!("    {} lines    {} words    {} bytes", len, cnt, bytes),
}
```

#### Rustの強み

- **網羅性チェック**: コンパイラが全ケースをチェック
- **可読性**: パターンが視覚的に明確
- **型安全性**: コンパイル時にパターンの妥当性を保証
- **効率性**: 最適化されたジャンプテーブル生成

---

### 🐹 Go: 4つの実装パターン

#### Pattern 1: Boolean Switch（最も直接的）

```go
switch {
case l_flg && !w_flg && !c_flg:
    fmt.Printf("    %d lines\n", len)
case l_flg && w_flg && !c_flg:
    fmt.Printf("    %d lines    %d words\n", len, cnt)
case l_flg && w_flg && c_flg:
    fmt.Printf("    %d lines    %d words    %d bytes\n", len, cnt, bytes)
case !l_flg && w_flg && !c_flg:
    fmt.Printf("    %d words\n", cnt)
case !l_flg && w_flg && c_flg:
    fmt.Printf("    %d words    %d bytes\n", cnt, bytes)
case !l_flg && !w_flg && c_flg:
    fmt.Printf("    %d bytes\n", bytes)
case l_flg && !w_flg && c_flg:
    fmt.Printf("    %d lines    %d bytes\n", len, bytes)
default:
    fmt.Printf("    %d lines    %d words    %d bytes\n", len, cnt, bytes)
}
```

**特徴:**

- ✅ 最も直接的で理解しやすい
- ❌ 冗長で保守性に課題
- ❌ ケース漏れの可能性

#### Pattern 2: ビットフラグ（推奨）

```go
flags := 0
if l_flg { flags |= 4 } // 100
if w_flg { flags |= 2 } // 010
if c_flg { flags |= 1 } // 001

switch flags {
case 4: // 100 (lines only)
    fmt.Printf("    %d lines\n", len)
case 6: // 110 (lines + words)
    fmt.Printf("    %d lines    %d words\n", len, cnt)
case 7: // 111 (all)
    fmt.Printf("    %d lines    %d words    %d bytes\n", len, cnt, bytes)
case 2: // 010 (words only)
    fmt.Printf("    %d words\n", cnt)
case 3: // 011 (words + bytes)
    fmt.Printf("    %d words    %d bytes\n", cnt, bytes)
case 1: // 001 (bytes only)
    fmt.Printf("    %d bytes\n", bytes)
case 5: // 101 (lines + bytes)
    fmt.Printf("    %d lines    %d bytes\n", len, bytes)
default: // 000 (default: all)
    fmt.Printf("    %d lines    %d words    %d bytes\n", len, cnt, bytes)
}
```

**特徴:**

- ✅ コンパクトで効率的
- ✅ Unix系ツールの伝統的手法
- ❌ ビット演算の理解が必要

#### Pattern 3: 文字列キー

```go
key := ""
if l_flg { key += "L" }
if w_flg { key += "W" }
if c_flg { key += "C" }

switch key {
case "L":
    fmt.Printf("    %d lines\n", len)
case "LW":
    fmt.Printf("    %d lines    %d words\n", len, cnt)
case "LWC":
    fmt.Printf("    %d lines    %d words    %d bytes\n", len, cnt, bytes)
case "W":
    fmt.Printf("    %d words\n", cnt)
case "WC":
    fmt.Printf("    %d words    %d bytes\n", cnt, bytes)
case "C":
    fmt.Printf("    %d bytes\n", bytes)
case "LC":
    fmt.Printf("    %d lines    %d bytes\n", len, bytes)
default:
    fmt.Printf("    %d lines    %d words    %d bytes\n", len, cnt, bytes)
}
```

**特徴:**

- ✅ 可読性が高い
- ✅ デバッグ時に状態が分かりやすい
- ❌ 文字列比較のオーバーヘッド

#### Pattern 4: 構造体ベース

```go
type OutputFlags struct {
    Lines bool
    Words bool
    Chars bool
}

func printOutput(flags OutputFlags, len, cnt, bytes int) {
    switch flags {
    case OutputFlags{true, false, false}:
        fmt.Printf("    %d lines\n", len)
    case OutputFlags{true, true, false}:
        fmt.Printf("    %d lines    %d words\n", len, cnt)
    case OutputFlags{true, true, true}:
        fmt.Printf("    %d lines    %d words    %d bytes\n", len, cnt, bytes)
    case OutputFlags{false, true, false}:
        fmt.Printf("    %d words\n", cnt)
    case OutputFlags{false, true, true}:
        fmt.Printf("    %d words    %d bytes\n", cnt, bytes)
    case OutputFlags{false, false, true}:
        fmt.Printf("    %d bytes\n", bytes)
    case OutputFlags{true, false, true}:
        fmt.Printf("    %d lines    %d bytes\n", len, bytes)
    default:
        fmt.Printf("    %d lines    %d words    %d bytes\n", len, cnt, bytes)
    }
}
```

**特徴:**

- ✅ 型安全性が高い
- ✅ 拡張性が良い
- ❌ 構造体比較のオーバーヘッド

---

### ⚖️ 比較分析

#### パフォーマンス比較

| 実装                | 実行速度   | メモリ使用量 | コンパイル最適化 |
| ------------------- | ---------- | ------------ | ---------------- |
| **Rust match**      | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐       |
| **Go ビットフラグ** | ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐   | ⭐⭐⭐⭐         |
| **Go Boolean**      | ⭐⭐⭐     | ⭐⭐⭐⭐     | ⭐⭐⭐           |
| **Go 文字列**       | ⭐⭐       | ⭐⭐⭐       | ⭐⭐             |
| **Go 構造体**       | ⭐⭐       | ⭐⭐⭐       | ⭐⭐             |

#### 保守性・可読性

| 実装                | 可読性     | 保守性     | 拡張性     | デバッグ容易性 |
| ------------------- | ---------- | ---------- | ---------- | -------------- |
| **Rust match**      | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐     |
| **Go 文字列**       | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐   | ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐     |
| **Go 構造体**       | ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐       |
| **Go Boolean**      | ⭐⭐⭐     | ⭐⭐       | ⭐⭐       | ⭐⭐⭐         |
| **Go ビットフラグ** | ⭐⭐       | ⭐⭐⭐     | ⭐⭐⭐⭐   | ⭐⭐           |

---

### 🎯 用途別推奨パターン

#### CLI ツール開発

- **Rust**: `match` expression（完璧な解決策）
- **Go**: ビットフラグパターン（Unix伝統に準拠）

#### Webアプリケーション

- **Rust**: `match` + enum（型安全性重視）
- **Go**: 構造体ベース（拡張性重視）

#### 高パフォーマンス要求

- **Rust**: `match`（最高効率）
- **Go**: ビットフラグ（効率とのバランス）

#### チーム開発

- **Rust**: `match`（コンパイラがサポート）
- **Go**: 文字列キーまたは構造体（可読性重視）

---

### 💡 実装のベストプラクティス

#### Rust

```rust
// カスタム型でより型安全に
#[derive(Debug)]
struct OutputOptions {
    lines: bool,
    words: bool,
    chars: bool,
}

impl OutputOptions {
    fn print_stats(&self, len: usize, cnt: usize, bytes: usize) {
        match (self.lines, self.words, self.chars) {
            (true, false, false) => println!("    {} lines", len),
            (true, true, false) => println!("    {} lines    {} words", len, cnt),
            // ... 他のパターン
        }
    }
}
```

#### Go

```go
// 定数での明確化
const (
    FlagLines = 1 << 2  // 4
    FlagWords = 1 << 1  // 2
    FlagChars = 1 << 0  // 1
)

func printStats(flags int, len, cnt, bytes int) {
    switch flags {
    case FlagLines:
        fmt.Printf("    %d lines\n", len)
    case FlagLines | FlagWords:
        fmt.Printf("    %d lines    %d words\n", len, cnt)
    // ...
    }
}
```

---

### 🔗 まとめ

#### 言語特性の活用

**Rust**:

- パターンマッチングの表現力を最大限活用
- コンパイラによる網羅性チェックで安全性確保
- 最高のパフォーマンスと可読性を両立

**Go**:

- シンプルな言語仕様内で実用的な解決策を模索
- 用途に応じてパターンを使い分け
- チーム開発での保守性を重視

どちらの言語でも目的は達成できますが、Rustの方がより表現力豊かで安全な実装が可能です。一方、Goは実装の選択肢が多く、チームのスキルレベルに応じて適切なパターンを選択できる柔軟性があります。
