---
id: 20250808152322
title:
type: technique
tags: []
created: 2025-08-08 15:23:22
updated: 2025-08-08 15:23:22
---

## Rust vs Go CLI開発 比較ノート

### 初期セットアップの違い

| 項目                 | Rust (clap)               | Go (cobra)                       |
| -------------------- | ------------------------- | -------------------------------- |
| **プロジェクト作成** | `cargo new` + `cargo add` | `go mod init` + `cobra-cli init` |
| **依存関係管理**     | Cargo.toml自動更新        | go.mod + 手動セットアップ        |
| **ボイラープレート** | 最小限                    | cobra-cli が大量生成             |

---

### アーキテクチャ設計の違い

#### Rust (clap)の特徴

- **型安全性重視**: `Option<PathBuf>`、`bool`型での厳密な型定義
- **派生マクロ活用**: `#[derive(Parser)]`で自動実装
- **所有権ベース**: `mut self`を消費するBuilder パターン
- **関数型指向**: メソッドチェーン`Args::parse().with_defaults()`

#### Go (cobra)の特徴

- **構造体ベース**: `cobra.Command`構造体での設定駆動
- **グローバル状態**: パッケージレベル変数での状態管理
- **ポインタレシーバー**: `(c *Config)`での副作用あり操作
- **手続き型指向**: `init()`関数での初期化処理

---

### 実装の複雑さ比較

#### 引数定義

**Rust**: 属性マクロで宣言的

```rust
#[arg(short = 'c', long, group = "output")]
pub bytes: bool,
```

**Go**: 関数呼び出しで命令的

```go
rootCmd.Flags().BoolVarP(&config.Bytes, "bytes", "c", false, "")
```

#### デフォルト値設定

**Rust**: Builderパターンで不変性保持

```rust
impl Args {
    pub fn with_defaults(mut self) -> Self { /* ... */ }
}
```

**Go**: 副作用ありメソッドで直接変更

```go
func (c *Config) withDefaults() {
    // 直接フィールドを変更
}
```

---

### パフォーマンス・メモリ管理

| 項目               | Rust               | Go                     |
| ------------------ | ------------------ | ---------------------- |
| **メモリ安全性**   | コンパイル時保証   | ランタイムGC           |
| **バイナリサイズ** | 静的リンクで大きめ | 比較的コンパクト       |
| **起動時間**       | 高速               | GC初期化でわずかに遅い |

---

### エラーハンドリング

**Rust**: Result型での関数型エラー処理

```rust
// clapが内部的にResult<Args, clap::Error>を使用
let args = Args::parse(); // panicまたは正常終了
```

**Go**: 明示的エラー値での手続き型処理

```go
err := rootCmd.Execute()
if err != nil {
    os.Exit(1)
}
```

---

### 開発者体験

#### Rust (clap)の利点

- 型安全性によるコンパイル時エラー検出
- マクロによるボイラープレートの削減
- 不変性による予期しない副作用の回避

#### Go (cobra)の利点

- 豊富な機能セット（サブコマンド、補完等）
- 直感的なAPI設計
- 豊富なドキュメントとコミュニティ

---

### 使い分けの指針

**Rustを選ぶべき場合**:

- 型安全性を重視するシステムツール
- パフォーマンスクリティカルなCLI
- 並行処理を多用するツール

**Goを選ぶべき場合**:

- 複雑なサブコマンド構造が必要
- チーム開発での保守性重視
- 迅速なプロトタイピングが必要
