---
id: 20250813144913
title: Rust vs Go Enumå‹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…æ¯”è¼ƒ
type: technique
tags: [rust, go, enum, validation]
created: 2025-08-13 14:49:13
updated: 2025-08-13 21:21:11
---

## Rust vs Go: Enumå‹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…æ¯”è¼ƒ

### æ¦‚è¦

Rustã®Enumå‹ã¨FromStrãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½¿ã£ãŸãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…ã¨ã€Goã§ã®åŒç­‰æ©Ÿèƒ½å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¯”è¼ƒåˆ†æã€‚
AWSã‚¯ãƒ©ã‚¦ãƒ‰ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒ»OSSé–‹ç™ºè€…å‘ã‘ã®å®Ÿç”¨çš„ãªè¨­è¨ˆæŒ‡é‡ã€‚

---

### ğŸ¦€ Rustå®Ÿè£…

#### åŸºæœ¬å®Ÿè£…

```rust
#[derive(Debug, Clone)]
pub enum OutputFormat {
    Auto,
    Json,
    Table,
    List,
    Csv,
}

impl std::str::FromStr for OutputFormat {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "auto" => Ok(OutputFormat::Auto),
            "json" => Ok(OutputFormat::Json),
            "table" => Ok(OutputFormat::Table),
            "list" => Ok(OutputFormat::List),
            "csv" => Ok(OutputFormat::Csv),
            _ => Err(Error::InvalidFormat(format!(
                "Invalid format: {}. Valid options: auto, json, table, list, csv",
                s
            ))),
        }
    }
}
```

#### ç‰¹å¾´

- **å‹å®‰å…¨æ€§**: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å…¨ã‚±ãƒ¼ã‚¹ã‚’å¼·åˆ¶
- **æ¨™æº–ãƒˆãƒ¬ã‚¤ãƒˆ**: `FromStr`ã«ã‚ˆã‚‹ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ è¦ªå’Œæ€§
- **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**: enumå€¤ã¯è»½é‡ï¼ˆdiscriminant + dataï¼‰
- **ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°**: ç¶²ç¾…æ€§ãƒã‚§ãƒƒã‚¯

---

### ğŸ¹ Goå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

#### Pattern 1: Switchæ–‡ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ¨å¥¨ï¼‰

```go
type OutputFormat string

const (
    OutputAuto  OutputFormat = "auto"
    OutputJson  OutputFormat = "json"
    OutputTable OutputFormat = "table"
    OutputList  OutputFormat = "list"
    OutputCsv   OutputFormat = "csv"
)

// ã‚ˆã‚Šæ„å›³ãŒæ˜ç¢ºãªå‘½å
func ParseOutputFormat(s string) (OutputFormat, error) {
    format := OutputFormat(strings.ToLower(s))
    if !format.IsValid() {
        return "", fmt.Errorf("invalid format: %s. valid options: auto, json, table, list, csv", s)
    }
    return format, nil
}

// ã¾ãŸã¯ FromStr ã«ã‚ˆã‚Šè¿‘ã„å‘½å
func OutputFormatFromString(s string) (OutputFormat, error) {
    format := OutputFormat(strings.ToLower(s))
    if !format.IsValid() {
        return "", fmt.Errorf("invalid format: %s. valid options: auto, json, table, list, csv", s)
    }
    return format, nil
}

func (o OutputFormat) IsValid() bool {
    switch o {
    case OutputAuto, OutputJson, OutputTable, OutputList, OutputCsv:
        return true
    default:
        return false
    }
}

func ValidOutputFormats() []OutputFormat {
    return []OutputFormat{OutputAuto, OutputJson, OutputTable, OutputList, OutputCsv}
}
```

#### Pattern 2: Map Lookupãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆéæ¨å¥¨ï¼‰

```go
type OutputFormat string

var AllowedFormat = map[OutputFormat]bool{
    "auto":  true,
    "json":  true,
    "table": true,
    "list":  true,
    "csv":   true,
}

func IsOutputFormat(format string) (OutputFormat, error) {
    outputFormat := OutputFormat(strings.ToLower(format))
    if !AllowedFormat[outputFormat] {
        return "", fmt.Errorf("invalid format: %s", format)
    }
    return outputFormat, nil
}
```

---

### âš–ï¸ å°‚é–€å®¶ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ

#### ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ

| å®Ÿè£…                    | ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦               | å®Ÿè¡Œé€Ÿåº¦             | æœ€é©åŒ–     |
| ----------------------- | ---------------------------- | -------------------- | ---------- |
| **Rust enum + FromStr** | `to_lowercase()`ã§Stringç”Ÿæˆ | é«˜é€Ÿï¼ˆmatchæœ€é©åŒ–ï¼‰  | â­â­â­â­â­ |
| **Go Switchæ–‡**         | `ToLower()`ã§stringç”Ÿæˆ      | é«˜é€Ÿï¼ˆswitchæœ€é©åŒ–ï¼‰ | â­â­â­â­   |
| **Go Map Lookup**       | stringç”Ÿæˆ + ãƒãƒƒã‚·ãƒ¥è¨ˆç®—    | ä¸­é€Ÿï¼ˆmap overheadï¼‰ | â­â­â­     |

**Winner**: Rust > Go Switch > Go Map

#### ğŸ›¡ï¸ å®‰å…¨æ€§ãƒ»ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

| é …ç›®                     | Rust       | Go Switch | Go Map |
| ------------------------ | ---------- | --------- | ------ |
| **ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ãƒã‚§ãƒƒã‚¯** | â­â­â­â­â­ | â­â­      | â­â­   |
| **å®Ÿè¡Œæ™‚å®‰å…¨æ€§**         | â­â­â­â­â­ | â­â­â­â­  | â­â­â­ |
| **ã‚¨ãƒ©ãƒ¼è©³ç´°åº¦**         | â­â­â­â­â­ | â­â­â­â­  | â­â­â­ |
| **ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ä¾å­˜**   | ãªã—       | ãªã—      | ã‚ã‚Š   |

**Winner**: Rust > Go Switch > Go Map

#### ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ»ä¿å®ˆæ€§

| é …ç›®                   | Rust       | Go Switch  | Go Map   |
| ---------------------- | ---------- | ---------- | -------- |
| **å¯èª­æ€§**             | â­â­â­â­   | â­â­â­â­â­ | â­â­â­   |
| **æ‹¡å¼µæ€§**             | â­â­â­â­â­ | â­â­â­â­   | â­â­â­â­ |
| **ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§**       | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­   |
| **è¨€èªã‚¤ãƒ‡ã‚£ã‚ªãƒ æº–æ‹ ** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­     |

**Winner**: Rust â‰ˆ Go Switch > Go Map

---

### ğŸ¯ æ¨å¥¨å®Ÿè£…æˆ¦ç•¥

#### Rustã§ã®å®Ÿè£…

- **åŸºæœ¬**: `enum` + `FromStr`ãƒˆãƒ¬ã‚¤ãƒˆ
- **æ‹¡å¼µ**: `Display`ã€`Serialize`/`Deserialize`ã‚‚å®Ÿè£…
- **ã‚¨ãƒ©ãƒ¼**: ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼å‹ã§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã‚’è±Šå¯Œã«

#### Goã§ã®å®Ÿè£…

- **åŸºæœ¬**: String-based constants + Switchæ–‡
- **æ‹¡å¼µ**: ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã§ã®æ¤œè¨¼ãƒ»å¤‰æ›æ©Ÿèƒ½
- **ã‚¨ãƒ©ãƒ¼**: æ¨™æº–`error`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ååˆ†

---

### ğŸ”„ å¯¾å¿œé–¢ä¿‚ãƒãƒƒãƒ—

| Rustæ¦‚å¿µ                    | Goç›¸å½“                      | å‚™è€ƒ                       |
| --------------------------- | --------------------------- | -------------------------- |
| `enum`                      | `type T string` + constants | Goã¯ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ãªã—     |
| `FromStr` trait             | Constructor function        | `NewXxx()` ãƒ‘ã‚¿ãƒ¼ãƒ³        |
| `Result<T, E>`              | `(T, error)`                | Goã®æ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° |
| `match` expression          | `switch` statement          | Goã¯å¼ã§ã¯ãªãæ–‡           |
| Compile-time exhaustiveness | Runtime validation          | Goã¯å®Ÿè¡Œæ™‚ãƒã‚§ãƒƒã‚¯         |

---

### ğŸ’¼ å®Ÿç”¨ä¾‹ï¼šAWS CLIé¢¨ãƒ„ãƒ¼ãƒ«

#### Rustå®Ÿè£…ä¾‹

```rust
// ä½¿ç”¨ä¾‹
let format: OutputFormat = "json".parse()?;
println!("Using format: {:?}", format);

// AWS SDKé€£æº
match format {
    OutputFormat::Json => serde_json::to_string(&response)?,
    OutputFormat::Table => format_as_table(&response),
    // ...
}
```

#### Goå®Ÿè£…ä¾‹

```go
// ä½¿ç”¨ä¾‹
format, err := NewOutputFormat("json")
if err != nil {
    return err
}
fmt.Printf("Using format: %s\n", format)

// AWS SDKé€£æº
switch format {
case OutputJson:
    return json.Marshal(response)
case OutputTable:
    return formatAsTable(response)
// ...
}
```

---

### ğŸ“š å­¦ç¿’ãƒã‚¤ãƒ³ãƒˆ

#### Rustã§ç¿’å¾—ã™ã¹ãæ¦‚å¿µ

1. **Ownership & Borrowing**: `&str` vs `String`ã®ä½¿ã„åˆ†ã‘
2. **Trait System**: æ¨™æº–ãƒˆãƒ¬ã‚¤ãƒˆã®æ´»ç”¨æ³•
3. **Error Handling**: `Result<T, E>`ã®æ…£ç”¨çš„ä½¿ç”¨
4. **Pattern Matching**: ç¶²ç¾…æ€§ã¨ã‚¬ãƒ¼ãƒ‰å¥

#### Goã§ç¿’å¾—ã™ã¹ãæ¦‚å¿µ

1. **Type Definitions**: `type` ã«ã‚ˆã‚‹æ–°ã—ã„å‹å®šç¾©
2. **Method Sets**: ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã®è¨­è¨ˆ
3. **Interface Satisfaction**: æš—é»™çš„ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…
4. **Error Conventions**: ã‚¨ãƒ©ãƒ¼å€¤ã®æ…£ç”¨çš„å‡¦ç†

---

### ğŸ› ï¸ é–‹ç™ºç’°å¢ƒã§ã®æ´»ç”¨

#### Rusté–‹ç™º

```toml
# Cargo.toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
clap = { version = "4.0", features = ["derive"] }
```

#### Goé–‹ç™º

```go
// go.mod
module myproject

go 1.21

require (
    github.com/spf13/cobra v1.7.0
)
```

---

### ğŸ¯ ã¾ã¨ã‚

#### è¨€èªé¸æŠæŒ‡é‡

**Rustã‚’é¸ã¶ã¹ãå ´åˆ:**

- æœ€é«˜ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå¿…è¦
- å‹å®‰å…¨æ€§ãŒé‡è¦ï¼ˆé‡‘èãƒ»åŒ»ç™‚ç³»ï¼‰
- é•·æœŸä¿å®ˆæ€§ã‚’é‡è¦–
- ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¦ä»¶

**Goã‚’é¸ã¶ã¹ãå ´åˆ:**

- é–‹ç™ºé€Ÿåº¦ã‚’é‡è¦–
- ãƒãƒ¼ãƒ é–‹ç™ºã§ã®å¯èª­æ€§ãŒé‡è¦
- ã‚¯ãƒ©ã‚¦ãƒ‰ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
- ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ãƒ»APIé–‹ç™º

#### ğŸ† ç·åˆè©•ä¾¡

**Rust**: ğŸ¥‡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»å®‰å…¨æ€§ã§åœ§å€’çš„
**Go Switch**: ğŸ¥ˆ å®Ÿç”¨æ€§ãƒ»é–‹ç™ºåŠ¹ç‡ã®ãƒãƒ©ãƒ³ã‚¹è‰¯å¥½  
**Go Map**: ğŸ¥‰ ç‰¹å®šç”¨é€”ã§ã®ã¿æœ‰åŠ¹
